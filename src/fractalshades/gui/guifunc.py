# -*- coding: utf-8 -*-
import typing
import functools
import os
import warnings
import inspect
from inspect import Signature, Parameter
import logging
import numbers
import textwrap

import mpmath
import numpy as np
from PyQt6 import QtGui

import fractalshades as fs
import fractalshades.models as fsm
import fractalshades.settings as settings
import fractalshades.colors as fscolors
import fractalshades.gui as fsgui

from fractalshades.postproc import (
    Postproc_batch,
    Continuous_iter_pp,
    DEM_normal_pp,
    Raw_pp,
)
from fractalshades.colors.layers import (
    Color_layer,
    Bool_layer,
    Normal_map_layer,
    Blinn_lighting
)

logger = logging.getLogger(__name__)


script_header = """# -*- coding: utf-8 -*-
\"""============================================================================
Programmatically generated by fractalshades (guifunc module).
Save to `<file>.py` and run as a python script:
    > python <file>.py
============================================================================\"""
import os
import typing

import numpy as np
import mpmath
from PyQt6 import QtGui

import fractalshades as fs
import fractalshades.models as fsm
import fractalshades.gui as fsgui
import fractalshades.colors as fscolors

from fractalshades.postproc import (
    Postproc_batch,
    Continuous_iter_pp,
    DEM_normal_pp,
    Fieldlines_pp,
    DEM_pp,
    Raw_pp,
)
from fractalshades.colors.layers import (
    Color_layer,
    Bool_layer,
    Normal_map_layer,
    Grey_layer,
    Virtual_layer,
    Blinn_lighting,
    Overlay_mode
)

def plot(plot_dir):"""

script_footer = """
if __name__ == "__main__":
    # Some magic to get the directory for plotting: with a name that matches
    # the file 
    realpath = os.path.realpath(__file__)
    plot_dir = os.path.splitext(realpath)[0]
    plot(plot_dir)
"""

def get_signature_details(s):
    """
    Utility method to extract the annotations, defaults and kwdefaults from a
    `Signature` object

    Parameters
    ----------
    s: Signature object

    Return
    ------
    annotations, defaults, kwonlydefaults
    """
    annotations = dict()
    defaults = []
    kwonlydefaults = dict()
    if s.return_annotation is not s.empty:
        annotations['return'] = s.return_annotation
    for p_name, p in s.parameters.items():
        if p.annotation is not s.empty:
            annotations[p_name] = p.annotation
        if p.default is not s.empty:
            # if p_name not in kwonly_names:
            if p.kind is not Parameter.KEYWORD_ONLY:
                defaults.append(p.default)
            else:
                kwonlydefaults[p_name] = p.default
    return annotations, defaults, kwonlydefaults


def set_signature(func_impl, func_signature):
    """
    Dynamically modifies a function signature.
    
    Parameters
    ----------
    func_impl: function with signature to be modified
    func_signature: inspect.Signature
    """
    # inspect.signature looks for the existence of a __signature__ attribute
    # before it looks at the function's actual signature:
    func_impl.__signature__ = func_signature
    # typing.get_type_hints does not respect __signature__,
    # so we shall update the __annotations__ attribute as well:
    (annotations, defaults, kwonlydefaults
     ) = get_signature_details(func_signature)

    defaults = tuple(defaults)
    if len(kwonlydefaults) == 0:
        kwonlydefaults = None

    func_impl.__annotations__ = annotations
    func_impl.__defaults__ = defaults
    func_impl.__kwdefaults__ = kwonlydefaults

# Note: to copy + modifiy a paramter, use:
# Parameter.replace from inspect module

class Code_writer:

    @staticmethod
    def write_assignment(varname, value, indent=0):
        """
        %varname = %value
        """
        shift = " " * (4 * indent)
        var_str = Code_writer.var_str(value, indent)
        str_assignment = f"{shift}{varname} = {var_str}"
        return str_assignment

    @staticmethod
    def var_str(var, indent=0):
        """
        (varname = )%value
        """
        shift = " " * (4 * indent)
        if isinstance(var, numbers.Number):
            return repr(var)
        if isinstance(var, str):
            return f'"{var}"'
        elif isinstance(var, mpmath.mpf):
            return repr(var)
        elif isinstance(var, dict):
            shift_inc = shift + " " * 4
            ret = (shift_inc).join([
                f"{Code_writer.var_str(k, indent+1)}: "
                f"{Code_writer.var_str(v, indent+1)},\n"
                for (k, v) in var.items()
            ])
            ret = f"{{\n{shift_inc}{ret}{shift}}}" # {{ for \{ in f-string
            return ret
        elif issubclass(var, fs.Fractal):
            ret = f"{var}"
            # ret = Code_writer.write_fractal(var, indent)
        else:
            raise NotImplementedError(var)


#    @staticmethod
#    def write_fractal(var, indent=0):
#        shift = "\n" + " " * (4 * indent)
#        fractal_class = write_fractal.__class__
#        init_dic = 
#        s = inspect.signature(fractal_class.__init__)
        

    @staticmethod
    def write_func(funcname, impl, indent=0):
        """
        def funcname():
            do stuff
        """
        shift = "\n" + " " * (4 * indent)
        ret = textwrap.dedent(inspect.getsource(impl))
        
        # changing the name
        beg = ret.find("(")
        ret = f"def {funcname}{ret[beg:]}"

        # Apply the indentation
        ret = shift.join(l for l in ret.splitlines())
        return shift + ret

    @staticmethod
    def call_func(funcname, kwargs, indent=0):
        """
        funcname(
           key1=value1,
           key2=value2,
           ...
        ):
        """
        shift = " " * (4 * indent)
        func_args = Code_writer.func_args(kwargs, indent + 1)
        str_call_func = f"{shift}ret = {funcname}(\n{func_args}{shift})"
        return str_call_func

    @staticmethod
    def func_args(kwargs, indent=0):
        """
           key1=value1,
           key2=value2,
        """
        shift = " " * (4 * indent)
        ret = shift.join([
            f"{k}={Code_writer.var_str(v)},\n"
            for (k, v) in kwargs.items()
        ])
        return shift + ret


class Plotting_Factory:
    """
    Only provides the basic frame without implementing a plot method
    Derived classes should implement

    Structure of the generated source code "wrapup" function
    
    closure = {..} # from plotting factory

    for func in funcs: # list from plotting factory
        kwargs = {..} # from GUI-input
        ret = func(closure, **gui_kwargs)
        closure.update(ret) # update the 'closure' for next func
    """
    def __init__(self, fractal_class, directory):
        self.fractal_class = fractal_class
        self.directory = directory


    def closure(self):
        """
        The closure dict needed for the first func
        """
        return {
            "fractal_class": self.fractal_class,
            "directory": self.directory
        }

    def func_keys(self):
        return (
            "general_settings",
            "fractal",
            # "raw_plot",
            "rendering",
        )

    def func(self, func_key):
        """ Return the implementation for the function identified by
        func_key"""
        return getattr(self, f"func_{func_key}")

    def func_general_settings(self):
        """ Tuning settings from fs.settings
        """
        def impl(
            closure,
            verbosity: int=2,
            chunk_size: float=200,
            inspect_calc: bool=False,
            enable_multithreading: bool=True
        ):
            fs.settings.verbosity = verbosity
            fs.settings.chunk_size = chunk_size
            fs.settings.inspect_calc = inspect_calc
            fs.settings.enable_multithreading = enable_multithreading
            return {}

        gui_signature = inspect.signature(functools.partial(impl, None))
        set_signature(impl, gui_signature)

        return impl

    def func_fractal(self):
        """
        Needed closure:  fractal_class
        Returned closure: fractal

        Based on the Fractal __init__ method, from which we
            - fine-tune the "directory" parameter
            - remove the "self" parameter
        """
        parameters = []
        s = inspect.signature(self.fractal_class.__init__)
        for p_name, param in s.parameters.items():
            if p_name == "self":
                continue
            if p_name == "directory":
                param = param.replace(default=self.directory)
            parameters += [param]

        def impl(closure, gui_kwargs):
            fractal_class = closure["fractal_class"]
            return {"fractal": fractal_class(**gui_kwargs)}

        gui_signature = Signature(
            parameters=parameters, return_annotation=Signature.empty)
        set_signature(impl, gui_signature)

        return impl

    def func_rendering(self):
        """
        Needed closure:  postproc_batches
        Returned closure: fractal plotter

        Based on the Fractal_plotter __init__ method, from which we
            - fine-tune the "postproc_batches" parameter
            - remove the "self" parameter
        """
        parameters = []
        s = inspect.signature(fs.Fractal_plotter.__init__)
        for p_name, param in s.parameters.items():
            if p_name in ["self", "postproc_batch"]:
                continue
            parameters += [param]

        def impl(closure_vars, gui_kwargs):
            postproc_batches = closure_vars["postproc_batches"]
            return {
                "plotter": fs.Fractal_plotter(postproc_batches, **gui_kwargs)
            }

        gui_signature = Signature(
            parameters=parameters, return_annotation=Signature.empty)
        set_signature(impl, gui_signature)

        return impl
    
    def func_raw_plot(self):
        pass


    def wrapup(self):
        """ 
        Returns the full plotting function
        """
        def impl(funcs_kwargs_dict):
            """
            funcs_kwargs_dict: mapping of func_key -> kwargs
                {}
            """
            closure = {
                "fractal_class": self.fractal_class,
                "directory": self.directory
            }
            for func_key, func_kwargs in funcs_kwargs_dict.items():
                # Calling the successive functions with the right
                # kwargs and closure
                ret = self.func(func_key)(
                    closure, func_kwargs[func_key]
                )
                closure.update(ret)
        return impl


    def wrapup_code(self, funcs_kwargs_dict):
        """
        Returns the source code for the full plotting function
        """
        indent = 1
        shift_inc = " " * (4 * indent)

        source_code = ""
        closure = {
            "fractal_class": self.fractal_class,
            "directory": self.directory
        }
        source_code += Code_writer.write_assignment(
            "closure",
            closure,
            indent
        )

        for func_key, func_kwargs in funcs_kwargs_dict.items():
            source_code += "\n" + Code_writer.write_func(
                f"func_{func_key}",
                self.func(func_key)(),
                indent
            )
            source_code += "\n" + Code_writer.call_func(
                f"func_{func_key}",
                func_kwargs,
                indent
            )
            source_code += f"\n{shift_inc}closure.update(ret)"

        return source_code

    def wrapup_guiparams_default(self):
        """
        Utilily function - return the parameters needed as input for wrapup
        """
        gui_params_default = dict()
        for func_key in self.func_keys():
            func = self.func(func_key)()
            sign = inspect.signature(func)
            gui_params_default[func_key] = {
                name: param.default 
                for name, param in sign.parameters.items()
            }
            
        return gui_params_default
            


#
#class Divmap_plotting_factory(Plotting_Factory):
#    
#    def __init__(self, fractal_class, directory, plot_interior=False,
#                 use_Milnor=False):
#        """
#        A plotting factory for divergent maps for which it is possible to
#        define a potential function
#        
#        Parameters
#        ----------
#        plot_interior: boolean
#            Activates the interior plotting option
#        use_Milnor: boolean
#            Activates the Milnor shading option
#        """
#        super().__init__(fractal_class, directory)
#        self.plot_interior = plot_interior
#        self.use_Milnor = use_Milnor
#
#
#    def plotting_scheme(self):
#        """
#        """
#        scheme = {
#            "Fractal instance": self.func_fractal,
#            "General parameters": self.func_gen_params,
#        }
#        if not self.plot_interior:
#            del scheme[""]
            
            

                
                





























#
#
#
#
#
#
#
#class oldFunc_factory():
#    # https://smarie.github.io/python-makefun/
#    # https://chriswarrick.com/blog/2018/09/20/python-hackery-merging-signatures-of-two-python-functions/
#    def __init__(self, fractal):
#        self.fractal = fractal
#        
#    def code_gen(self, type="plot"):
#        """
#        Returns a dictionnary, e.g.,
#        
#        kind = "plot":
#            - "zoom" -> func
#            - "plot_batch_xxx" -> func
#            - "plot_batch_yyy" -> func
#            - "Extra outputs" -> func
#            - "HQ rendering" -> func
#            - "General settings" -> func
#
#        func codes blocks are just pass-through parameters
#        
#        then the hard work is done in "wrap_up"
#        """
#        func_dict = NotImplemented
#        wrap_up = NotImplemented
#        return func_dict, wrap_up
#
#
#    def gui_plot_func(self):
#        """
#        Main idea : we build step by steps the function blocks and signature in
#        parallel. Main blacks:
#
#        1) zoom
#            1.1) skew
#        2) divergent_calc
#            2.1) divergent_base_field
#            2.2) divergent_optionnal_field
#            2.3) divergent_shading
#        3) convergent_calc
#           3.1) convergent_base_field
#           3.2) convergent_shading
#        4) Extra outputs
#        5) Final rendering
#        6) General settings
#        """
#        # 1) Zoom
#        zoom_impl, zoom_params, chapter = self.zoom_code(0)
#
#        # 2) Base_calc
#        calc_impl, calc_params, chapter = self.calc_code("calc_std_div", chapter)
#
#        # 3) layer
##        print("zoom_params", zoom_params, zoom_params.keys)
##        print("calc_params", calc_params)
#        
#        #  Error on duplicates
#        full_pnames = tuple(p.name for p in (zoom_params + calc_params))
#        if len(full_pnames) != len(set(full_pnames)):
#            raise ValueError(
#                    f"Found duplicates in parameters name: {full_pnames}"
#            )
#        
#
#        def func_impl(**kwargs):
#            
#            
#            # Zooming parameters
#            zoom_pnames = (p.name for p in zoom_params)
#            zoom_kwargs = {k: kwargs[k] for k in zoom_pnames}
#            zoom_impl(**zoom_kwargs)    
#
#            # First calculation
#            calc_pnames = (p.name for p in calc_params)
#            calc_kwargs = {k: kwargs[k] for k in calc_pnames}
#            pp_batch = calc_impl(**calc_kwargs)
#            
#            # First layers
#            
#            # Second calculation
#            
#            # Second layers
#            
#            # Clean-up
#            
#            
#            
##            div_calc(**div_calc_params)
##
##            # Second calculation
##            cv_calc(**cv_calc_params)
##
##            # Layers for div calc
##            div_base_layer(**div_base_layer_params)
##            div_2nd_layer(**div_2nd_layer_params)
##            div_shade(**div_shade_params)
##
##            # Layers for cv calc
##            cv_base_layer(**c""v_base_layer_params)
##            cv_2nd_layer(**cv_2nd_layer_params)
##            cv_shade(**cv_shade_params)
#
#        func_sig = Signature(zoom_params + calc_params)
#        set_signature(func_impl, func_sig)
#        func_impl.__doc__ = f"""Plotting function dynamically generated for:
#        {self.fractal.__class__}
#        """
#        return func_impl
#
#
#    def zoom_code(self, chapter: int):
#        """
#        Generate code for zooming into this fractal
#        Skew parameters included in a subsection (only for non-holomorphic)
#        """
#        f = self.fractal
#        s = inspect.signature(f.zoom)
#        
#        # Create the "Zoom" section
#        param = chapter_param(chapter, "Zoom parameters")
#        chapter += 1
#        chapter_names = [param.name]
#        zoom_params = [param]
#
#        # Do we need skew ? Only if flagged explicitely as non-holomorphic
#        need_skew = False
#        triggered_skew = False
#        if hasattr(f, "holomorphic"):
#            need_skew = not(f.holomorphic)
#
#        for p_name, p in s.parameters.items():
#
#            if "skew" in p_name:
#                if not(need_skew):
#                    continue
#                if not(triggered_skew):
#                    triggered_skew = True
#                    param = chapter_param(chapter, "Skew matrix")
#                    chapter += 1
#                    chapter_names += [param.name]
#                    zoom_params += [param]
#
#            zoom_params += passed_through_param(p_name, p)
#
#        def zoom_impl(**kwargs):
#            # Just remove the headers and we are done
#            for name in chapter_names:
#                kwargs.pop(name)
#            self.fractal.zoom(**kwargs)
#
#        return (zoom_impl, zoom_params, chapter)
#
#    def calc_code(self, calc_name, chapter: int, subset=None):
#        """
#        Generate code for a calculation
#        Subset is either None or need to be passed as keyword
#        """
#        f = self.fractal
#        s = inspect.signature(getattr(f, calc_name))
#        
#        # Create the "Calc" section
#        param = chapter_param(chapter, f"{calc_name} parameters")
#        chapter += 1
#        chapter_names = [param.name]
#        calc_params = [param]
#
#        for p_name, p in s.parameters.items():
#            if "subset" in p_name:
#                continue
#            calc_params += passed_through_param(p_name, p)
#
#        def calc_impl(**kwargs):
#            for name in chapter_names:
#                kwargs.pop(name)
#            kwargs["subset"] = subset
#            getattr(f, calc_name)(**kwargs)
#            return Postproc_batch(fractal, kwargs["calc_name"])
#
#        return (calc_impl, calc_params, chapter)
#
#
#    def base_layer_code(self, calc_name, layer_name, chapter: int):
#        """
#        """
#        f = self.fractal
#        s = inspect.signature(getattr(f, calc_name))
#         
#        # Create the "Calc" section
#        param = chapter_param(chapter, f"{calc_name} base layer")
#        chapter += 1
#        chapter_names = [param.name]
#        calc_params = [param]
#
#        def layer_impl(**kwargs):
#            # remove the headers
#            for name in chapter_names:
#                kwargs.pop(name)
#            # get the postproc batch
#            pp_batch = kwargs.pop("pp_batch")
#
#            pp_batch.add_postproc("base_layer", Continuous_iter_pp())
#
#
#def chapter_param(chapter_index, title):
#    """ Returns a fsgui.separator Parameter based on index & title"""
#    return Parameter(
#        "_" + str(chapter_index),
#        kind=Parameter.KEYWORD_ONLY,
#        default=title,
#        annotation=fsgui.separator
#    )
#
#
#def passed_through_param(p_name, p):
#    """ Returns a fsgui.separator Parameter based on index & title"""
#    if p.annotation is Signature.empty:
#        warnings.warn(f"Missing annotation for {p_name}")
#        return []
#    return [Parameter(
#        p_name,
#        kind=Parameter.KEYWORD_ONLY,
#        default=p.default,
#        annotation=p.annotation
#    )]
#
#def params_to_names(plist):
#    return [p.name for p in plist]

#def set_signature(func_impl, func_signature):
#    """
#    Dynamically modifies a function with signature with `func_signature`
#    
#    Parameters
#    ----------
#    func_impl: function with signature to be modified
#    func_signature: inspect.Signature
#    """
#    # inspect.signature looks for the existence of a __signature__ attribute
#    # before it looks at the function's actual signature:
#    func_impl.__signature__ = func_signature
#
#    # typing.get_type_hints does not respect __signature__,
#    # so we should update the __annotations__ attribute as well:
#    annotations, defaults, kwonlydefaults = get_signature_details(func_signature)
#    print("annotations, defaults, kwonlydefaults", annotations, defaults, kwonlydefaults)
#
#    defaults = tuple(defaults)
#    if len(kwonlydefaults) == 0:
#        kwonlydefaults = None
#
#    func_impl.__annotations__ = annotations
#    func_impl.__defaults__ = defaults
#    func_impl.__kwdefaults__ = kwonlydefaults


#def get_signature_details(s):
#    """
#    Utility method to extract the annotations, defaults and kwdefaults from a `Signature` object
#    :param s:
#    :return:
#    """
#    annotations = dict()
#    defaults = []
#    kwonlydefaults = dict()
#    if s.return_annotation is not s.empty:
#        annotations['return'] = s.return_annotation
#    for p_name, p in s.parameters.items():
#        if p.annotation is not s.empty:
#            annotations[p_name] = p.annotation
#        if p.default is not s.empty:
#            # if p_name not in kwonly_names:
#            if p.kind is not Parameter.KEYWORD_ONLY:
#                defaults.append(p.default)
#            else:
#                kwonlydefaults[p_name] = p.default
#    return annotations, defaults, kwonlydefaults
def test_Code_writer():
    val = np.pi
    val = {"abs": np.pi, "c": 4.59785}
    a = val
    for a in (
        np.pi,
        {"abs": np.pi, "c": 4.59785},
        {1: np.pi, 2: "xxx", 3: {"abs": np.pi, "c": 4.59785}},
    ):
        res = Code_writer.write_assignment("test", a, 1)
        print(f"res({a}):\n{res}")
    
    def f(x):
        return x
    
    res = Code_writer.write_func("ff", f, indent=1)
    print(f"func f:\n{res}")
    
    res = Code_writer.call_func("f", {"abs": np.pi, "c": 4.59785}, indent=1)
    print(f"func f:\n{res}")
    

if __name__ == "__main__":
    realpath = os.path.realpath(__file__)
    directory = os.path.splitext(realpath)[0]
    fractal_c = fsm.Perturbation_mandelbrot# (directory)

    pf = Plotting_Factory(fractal_c, directory)
    
    guiparams_default = pf.wrapup_guiparams_default()
    print("guiparams_default", guiparams_default)

    gui_source_code = pf.wrapup_code(guiparams_default)
    
    print("************* gui_source_code:\n", gui_source_code)
    
#    print(f_impl)
#    
#    print("*** signature:\n", inspect.signature(f_impl))
#    print("*** signature:\n", f_impl.__signature__)
#    print("*** source:\n", inspect.getsource(f_impl))
#    print("*** doc:\n", f_impl.__doc__)
    
#    f = f_impl(directory=directory)
#    print("")
#    
#    print(get_signature_details(f_impl.__signature__))
#    print(f_impl.__closure__[0].cell_contents)
    # test_Code_writer()
    
    # print(func.__annotations__)
    # func(x="0.", y="0.", dx="5.0")
    
#    sign = inspect.signature(func, follow_wrapped=False)
#    for i_param, (name, param) in enumerate(sign.parameters.items()):
#        print(i_param, name, param)



#
#
#def generic_plot(plot_dir, fractal, **user_kwargs):
#    """
#    This will launch a GUI explorer with functionalities offered by the 
#    fractal class
#    """
#    field_dic = fractal.field_dic
#    
#    # Typing
#    shade_kind_type = typing.Literal["None", "standard", "glossy"]
#    
#    
#    x = '-1.0'
#    y = '-0.0'
#    dx = '5.0'
#    calc_name = 'test'
#
#    xy_ratio = 1.0
#    dps = 16
#    max_iter = 15000
#    M_divergence = 1.e2
#    nx = 800
#    theta_deg = 0.
#    interior_detect = True
#    epsilon_stationnary = 0.001
#    eps = 1.e-6
#    
#    base_layer = "continuous_iter"
#    colormap = fscolors.cmap_register["classic"]
#    cmap_z_kind = "relative"
#    zmin = 0.00
#    zmax = 0.50
#    
#    shade_kind="glossy"
#    field_kind="None"
#
#    # Set to True to enable multi-threading
#    settings.enable_multithreading = False
#
#    directory = plot_dir
#    fractal = fsm.Perturbation_mandelbrot(directory)
#    
#    def func(
#        fractal: fsm.Perturbation_mandelbrot=fractal,
#         calc_name: str=calc_name,
#
#         _1: fsgui.separator="Zoom parameters",
#         x: mpmath.mpf=x,
#         y: mpmath.mpf=y,
#         dx: mpmath.mpf=dx,
#         xy_ratio: float=xy_ratio,
#         theta_deg: float=theta_deg,
#         dps: int=dps,
#         nx: int=nx,
#         antialiasing: bool=False,
#
#         _2: fsgui.separator="Calculation parameters",
#         max_iter: int=max_iter,
#         M_divergence: float=M_divergence,
#         interior_detect: bool=interior_detect,
#         epsilon_stationnary: float=epsilon_stationnary,
#
#         _3: fsgui.separator="Bilinear series parameters",
#         use_BLA: bool=True,
#         eps: float=eps,
#
#         _4: fsgui.separator="Plotting parameters: base field",
#         base_layer: typing.Literal[
#                 "continuous_iter",
#                 "distance_estimation"
#         ]=base_layer,
#         interior_mask: typing.Literal[
#                 "all",
#                 "not_diverging",
#                 "dzndz_detection",
#         ]="all",
#         interior_color: QtGui.QColor=(0.1, 0.1, 0.1),
#         colormap: fscolors.Fractal_colormap=colormap,
#         invert_cmap: bool=False,
#         # cmap_z_kind: typing.Literal["relative", "absolute"]=cmap_z_kind,
#         zmin: float=zmin,
#         zmax: float=zmax,
#
#         _5: fsgui.separator="Plotting parameters: shading",
#         shade_kind: typing.Literal["None", "standard", "glossy"]=shade_kind,
#         gloss_intensity: float=10.,
#         light_angle_deg: float=65.,
#         light_color: QtGui.QColor=(1.0, 1.0, 1.0),
#         gloss_light_color: QtGui.QColor=(1.0, 1.0, 1.0),
#
#         _6: fsgui.separator="Plotting parameters: field lines",
#         field_kind: typing.Literal["None", "overlay", "twin"]=field_kind,
#         n_iter: int=3,
#         swirl: float=0.,
#         damping_ratio: float=0.8,
#         twin_intensity: float=0.1
#    ):
#
#        fractal.zoom(
#            precision=dps,
#            x=x,
#            y=y,
#            dx=dx,
#            nx=nx,
#            xy_ratio=xy_ratio,
#            theta_deg=theta_deg,
#            projection="cartesian",
#            antialiasing=antialiasing
#        )
#        
#        print("DEBUGGING zoom", fractal.zoom_kwargs)
#
#        if use_BLA:
#            BLA_params={"eps": eps}
#        else:
#            BLA_params = None
#            
#        fractal.calc_std_div(
#                calc_name=calc_name,
#                subset=None,
#                max_iter=max_iter,
#                M_divergence=M_divergence,
#                epsilon_stationnary=epsilon_stationnary,
#                SA_params=None,
#                BLA_params=BLA_params,
#                interior_detect=interior_detect,
#            )
#
#        if fractal.res_available(calc_name):
#            print("RES AVAILABLE, no compute")
#        else:
#            print("RES NOT AVAILABLE, clean-up")
#            fractal.clean_up(calc_name)
#
##        fractal.run()
#
#        pp = Postproc_batch(fractal, calc_name)
#        
#        if base_layer == "continuous_iter":
#            pp.add_postproc(base_layer, Continuous_iter_pp())
#        elif base_layer == "distance_estimation":
#            pp.add_postproc("continuous_iter", Continuous_iter_pp())
#            pp.add_postproc(base_layer, DEM_pp())
#
#        if field_kind != "None":
#            pp.add_postproc(
#                "fieldlines",
#                Fieldlines_pp(n_iter, swirl, damping_ratio)
#            )
#
#        interior_func = {
#            "all": lambda x: x != 1,
#            "not_diverging": lambda x: x == 0,
#            "dzndz_detection": lambda x: x == 2,
#        }[interior_mask]
#        pp.add_postproc("interior", Raw_pp("stop_reason", func=interior_func))
#
#        if shade_kind != "None":
#            pp.add_postproc("DEM_map", DEM_normal_pp(kind="potential"))
#
#        plotter = fs.Fractal_plotter(pp)
#
#        plotter.add_layer(Bool_layer("interior", output=False))
#
#        if field_kind == "twin":
#            plotter.add_layer(Virtual_layer(
#                    "fieldlines", func=None, output=False
#            ))
#        elif field_kind == "overlay":
#            plotter.add_layer(Grey_layer(
#                    "fieldlines", func=None, output=False
#            ))
#
#        if shade_kind != "None":
#            plotter.add_layer(Normal_map_layer(
#                "DEM_map", max_slope=60, output=True
#            ))
#
#        if base_layer != 'continuous_iter':
#            plotter.add_layer(
#                Virtual_layer("continuous_iter", func=None, output=False)
#            )
#
#        sign = {False: 1., True: -1.}[invert_cmap]
#        plotter.add_layer(Color_layer(
#                base_layer,
#                func=lambda x: sign * np.log(x),
#                colormap=colormap,
#                probes_z=[zmin, zmax],
#                probes_kind=cmap_z_kind,
#                output=True))
#        plotter[base_layer].set_mask(
#            plotter["interior"], mask_color=interior_color
#        )
#
#        if field_kind == "twin":
#            plotter[base_layer].set_twin_field(plotter["fieldlines"],
#                   twin_intensity)
#        elif field_kind == "overlay":
#            overlay_mode = Overlay_mode("tint_or_shade", pegtop=1.0)
#            plotter[base_layer].overlay(plotter["fieldlines"], overlay_mode)
#
#        if shade_kind != "None":
#            light = Blinn_lighting(0.4, np.array([1., 1., 1.]))
#            light.add_light_source(
#                k_diffuse=0.8,
#                k_specular=.0,
#                shininess=350.,
#                angles=(light_angle_deg, 20.),
#                coords=None,
#                color=np.array(light_color))
#
#            if shade_kind == "glossy":
#                light.add_light_source(
#                    k_diffuse=0.2,
#                    k_specular=gloss_intensity,
#                    shininess=1400.,
#                    angles=(light_angle_deg, 20.),
#                    coords=None,
#                    color=np.array(gloss_light_color))
#    
#            plotter[base_layer].shade(plotter["DEM_map"], light)
#
#        plotter.plot()
#        
#        # Renaming output to match expected from the Fractal GUI
#        layer = plotter[base_layer]
#        file_name = "{}_{}".format(type(layer).__name__, layer.postname)
#        src_path = os.path.join(fractal.directory, file_name + ".png")
#        dest_path = os.path.join(fractal.directory, calc_name + ".png")
#        if os.path.isfile(dest_path):
#            os.unlink(dest_path)
#        os.link(src_path, dest_path)
#
#
#    gui = fsgui.Fractal_GUI(func)
#    gui.connect_image(image_param="calc_name")
#    gui.connect_mouse(x="x", y="y", dx="dx", xy_ratio="xy_ratio", dps="dps")
#    gui.show()

