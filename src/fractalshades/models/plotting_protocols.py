# -*- coding: utf-8 -*-
import sys
import typing
import functools
import os
import warnings
import inspect
from inspect import Signature, Parameter
import logging
import numbers
import textwrap

import mpmath
import numpy as np
#
import fractalshades
import fractalshades as fs
from fractalshades.postproc import Fractal_array
#import fractalshades.models as fsm
#import fractalshades.settings as settings
#import fractalshades.colors as fscolors
#import fractalshades.gui as fsgui
#
from fractalshades.postproc import (
    Postproc_batch,
#    Continuous_iter_pp,
#    DEM_normal_pp,
#    Raw_pp,
)
#from fractalshades.colors.layers import (
#    Color_layer,
#    Bool_layer,
#    Normal_map_layer,
#    Blinn_lighting
#)

logger = logging.getLogger(__name__)

separator = typing.TypeVar('gui_separator')

script_header = """# -*- coding: utf-8 -*-
\"""============================================================================
Programmatically generated by fractalshades (guifunc module).
Save to `<file>.py` and run as a python script:
    > python <file>.py
============================================================================\"""
import os
import typing

import numpy as np
import mpmath
from PyQt6 import QtGui

import fractalshades as fs
import fractalshades.models as fsm
import fractalshades.gui as fsgui
import fractalshades.colors as fscolors

from fractalshades.postproc import (
    Postproc_batch,
    Continuous_iter_pp,
    DEM_normal_pp,
    Fieldlines_pp,
    DEM_pp,
    Raw_pp,
)
from fractalshades.colors.layers import (
    Color_layer,
    Bool_layer,
    Normal_map_layer,
    Grey_layer,
    Virtual_layer,
    Blinn_lighting,
    Overlay_mode
)

def plot(plot_dir):"""

script_footer = """
if __name__ == "__main__":
    # Some magic to get the directory for plotting: with a name that matches
    # the file 
    realpath = os.path.realpath(__file__)
    plot_dir = os.path.splitext(realpath)[0]
    plot(plot_dir)
"""

def get_signature_details(s):
    """
    Utility method to extract the annotations, defaults and kwdefaults from a
    `Signature` object

    Parameters
    ----------
    s: Signature object

    Return
    ------
    annotations, defaults, kwonlydefaults
    """
    annotations = dict()
    defaults = []
    kwonlydefaults = dict()
    if s.return_annotation is not s.empty:
        annotations['return'] = s.return_annotation
    for p_name, p in s.parameters.items():
        if p.annotation is not s.empty:
            annotations[p_name] = p.annotation
        if p.default is not s.empty:
            # if p_name not in kwonly_names:
            if p.kind is not Parameter.KEYWORD_ONLY:
                defaults.append(p.default)
            else:
                kwonlydefaults[p_name] = p.default
    return annotations, defaults, kwonlydefaults


def set_signature(func_impl, func_signature):
    """
    Dynamically modifies a function signature.
    
    Parameters
    ----------
    func_impl: function with signature to be modified
    func_signature: inspect.Signature
    """
    # inspect.signature looks for the existence of a __signature__ attribute
    # before it looks at the function's actual signature:
    func_impl.__signature__ = func_signature
    # typing.get_type_hints does not respect __signature__,
    # so we shall update the __annotations__ attribute as well:
    (annotations, defaults, kwonlydefaults
     ) = get_signature_details(func_signature)

    defaults = tuple(defaults)
    if len(kwonlydefaults) == 0:
        kwonlydefaults = None

    func_impl.__annotations__ = annotations
    func_impl.__defaults__ = defaults
    func_impl.__kwdefaults__ = kwonlydefaults



def partial_sgn(func, params_dict):
    """
    Parameters:
    ----------
    func: callable
        The func whose signature will be modified, keyword only can be modified
    params_dict: dict (keys -> values)
        keys : a subset of the func parameters
        values:
            - either a paramter assignement (in this case we remove from the
               func signature and add it to the 'imposed' values)
            - or a inspect.Parameter (in this case we replace in the signature)
            - or None (we just remove from signature)
    
    Returns:
    --------
    sgn, imposed_params
    """
    sgn_params = []
    imposed_params = dict()
    for p_name, param in inspect.signature(func).parameters.items():
        if not(p_name in params_dict):
            sgn_params += [param]
            continue
        pval = params_dict[p_name]
        if isinstance(pval, inspect.Parameter):
            sgn_params += pval
            continue
        elif pval is None:
            continue
        else:
            imposed_params[p_name] = pval

    sgn = Signature(
            parameters=sgn_params, return_annotation=Signature.empty
    )
    return sgn, imposed_params
     
        

# Note: to copy + modifiy a paramter, use:
# Parameter.replace from inspect module

class Code_writer:
    """
    A list of static methods allowing to write Python source code
    """
    @staticmethod
    def write_assignment(varname, value, indent=0):
        """
        %varname = %value
        """
        shift = " " * (4 * indent)

        try:
            var_str = Code_writer.var_str(value, indent)
        except NotImplementedError: # rethrow with hopefully better descr
            raise NotImplementedError(varname, value)

        str_assignment = f"{shift}{varname} = {var_str}\n"
        # print("varname", f"*{varname}*", f"*{shift}{varname}*", f"*{str_assignment}*")
        return str_assignment

    @staticmethod
    def var_str(var, indent=0):
        """
        'value' part of assignment:
        (varname = )%value
        """
        shift = " " * (4 * indent)
        if var is None:
            return "None"
        if isinstance(var, numbers.Number):
            return repr(var)
        if isinstance(var, str):
            return f'"{var}"'
        elif isinstance(var, mpmath.mpf):
            return repr(var)
        elif isinstance(var, dict):
            shift_inc = shift + " " * 4
            ret = (shift_inc).join([
                f"{Code_writer.var_str(k, indent+1)}: "
                f"{Code_writer.var_str(v, indent+1)},\n"
                for (k, v) in var.items()
            ])
            ret = f"{{\n{shift_inc}{ret}{shift}}}" # {{ for \{ in f-string
            return ret
        elif isinstance(var, list):
            shift_inc = shift + " " * 4
            ret = (shift_inc).join([
                f"{Code_writer.var_str(v, indent+1)},\n"
                for v in var
            ])
            ret = f"[\n{shift_inc}{ret}{shift}]" # {{ for \{ in f-string
            return ret
        elif inspect.isclass(var):
            ret = f"{Code_writer.fullname(var)}"
            return ret
            # ret = Code_writer.write_fractal(var, indent)
        else:
            raise NotImplementedError(var)
    
    def fullname(_class):
        module = _class.__module__
        if module == 'builtins':
            return _class.__qualname__ # avoid outputs like 'builtins.str'
        return module + '.' + _class.__qualname__


#    @staticmethod
#    def write_fractal(var, indent=0):
#        shift = "\n" + " " * (4 * indent)
#        fractal_class = write_fractal.__class__
#        init_dic = 
#        s = inspect.signature(fractal_class.__init__)
        

    @staticmethod
    def write_func(funcname, impl, indent=0):
        """
        def funcname():
            do stuff
        """
        shift = "\n" + " " * (4 * indent)
        ret = textwrap.dedent(inspect.getsource(impl))
        
        # changing the name
        beg = ret.find("(")
        ret = f"def {funcname}{ret[beg:]}\n"

        # Apply the indentation
        ret = shift.join(l for l in ret.splitlines())
        return shift + ret

    @staticmethod
    def call_func(funcname, kwargs, indent=0):
        """
        funcname(
           key1=value1,
           key2=value2,
           ...
        ):
        """
        shift = " " * (4 * indent)
        func_args = Code_writer.func_args(kwargs, indent + 1)
        str_call_func = f"{shift}ret = {funcname}(\n{func_args}{shift})"
        return str_call_func

    @staticmethod
    def call_func_direct(funcname, func_args, indent=0):
        """
        funcname(func_args):
        """
        shift = " " * (4 * indent)
        shift_arg = " " * (4 * (indent+1))
        func_args = func_args.replace(", ", ",")
        func_args = (
            shift_arg
            + (",\n" + shift_arg).join(func_args.split(","))
            + "\n"
        )
        
        str_call_func = f"{shift}ret = {funcname}(\n{func_args}{shift})"
        return str_call_func

    @staticmethod
    def func_args(kwargs, indent=0):
        """
           key1=value1,
           key2=value2,
        """
        shift = " " * (4 * indent)
        try:
            ret = shift.join([
                f"{k}={Code_writer.var_str(v)},\n"
                for (k, v) in kwargs.items()
            ])
        except NotImplementedError:
            etype, evalue, etraceback = sys.exc_info()
            raise  NotImplementedError(f"{evalue}  raised from {kwargs}")

        return shift + ret


class Plotting_Factory:
    """
    The main purposes of this plotting factory class is:
        - generate the functions + signatures used by the gui: method *wrapup*
        - generate the equivalent python source code to run in batch mode:
          method *wrapup_code*

    Structure of the generated source code "wrapup" function (compilation of
    several add-hoc functions)

    closure = {..} # dict for data used by successive func calls

    for func in funcs: # list from plotting factory
        kwargs = {..} # from GUI-input
        ret = func(closure, **gui_kwargs)
        closure.update(ret) # update the 'closure' for next func
    """
    def __init__(self, fractal_class, directory):
        self.fractal_class = fractal_class
        self.directory = directory

    def closure(self, funcs_kwargs_dict):
        """
        The closure "bootstrap" dict needed to call the GUI components
        functions (hence the *closure* name), fed to the first func call.
        It will grow with successive calls
        """
        activated_calc = self.activated_calcs(
                self.fractal_class, funcs_kwargs_dict
        )
        
        return {
            "fractal_class": self.fractal_class,
            "directory": self.directory,
            "activated_calc": activated_calc
        }

    def activated_calcs(self, fractal_class, funcs_kwargs_dict):
        """ Gathers the activated calculations from the layers params"""
        # This is fine tuning ; for the moement lets be brutal
        calculations = fractal_class._plot_protocol
        return list(calculations.keys())
        

    def func_keys(self):
        """
        The break-down of wrap-up func in successive items
        """
        return (
            "general_settings",
            "fractal",
            "zoom",
            "calc",
            # "layers",
            "rendering",
        )

    def func(self, func_key):
        """ Return the implementation for the function identified by
        func_key"""
        return getattr(self, f"func_{func_key}")


    def func_general_settings(self):
        """ Allows tuning programm settings from fs.settings
        """
        def impl(
            closure,
            verbosity: int=2,
            chunk_size: float=200,
            inspect_calc: bool=False,
            enable_multithreading: bool=True
        ):
            fractalshades.settings.verbosity = verbosity
            fractalshades.settings.chunk_size = chunk_size
            fractalshades.settings.inspect_calc = inspect_calc
            fractalshades.settings.enable_multithreading = enable_multithreading
            return {}

        gui_signature = inspect.signature(functools.partial(impl, None))
        set_signature(impl, gui_signature)

        return impl

    def func_fractal(self):
        """
        Genrerates the fractal instance

        Needed closure:  fractal_class
        Returned closure: fractal

        Based on the Fractal __init__ method, from which we
            - fine-tune the "directory" parameter
            - remove the "self" parameter
        """
        def impl(closure, fractal_kwargs):
            fractal_class = closure["fractal_class"]
            return {"fractal": fractal_class(**fractal_kwargs)}

        parameters = []
        s = inspect.signature(self.fractal_class.__init__)
        for p_name, param in s.parameters.items():
            if p_name == "self":
                continue
            if p_name == "directory":
                param = param.replace(default=self.directory)
            parameters += [param]

        gui_signature = Signature(
            parameters=parameters, return_annotation=Signature.empty)
        set_signature(impl, gui_signature)

        return impl
    
    def func_zoom(self):
        """
        Apply the zoom settings

        Needed closure: fractal
        Returned closure: projection

        Based on the fractal zoom method, from which we:
            - fine-tune the "directory" parameter
            - remove the "self" parameter
        """
        def impl(closure, zoom_kwargs):
            fractal = closure["fractal"]
            fractal.zoom(**zoom_kwargs)
            return {}

        parameters = []
        zoom = self.fractal_class.zoom

        s = inspect.signature(zoom)
        for p_name, param in s.parameters.items():
            if p_name == "self":
                continue
            if p_name == "directory":
                param = param.replace(default=self.directory)
            parameters += [param]

        gui_signature = Signature(
            parameters=parameters, return_annotation=Signature.empty
        )
        set_signature(impl, gui_signature)

        return impl

    def func_calc(self):
        """
        Setup the calculations ; Delegated to the fractal Plotting_protocol
        mixin.
        
        Needed closure:  fractal
        Returned closure: postproc_batches
        """
        calc_sign = Implements.calc(self.fractal_class, sgn_only=True)

        def impl(closure_vars, calc_kwargs):
            fractal = closure_vars["fractal"]
            activated_calc = closure_vars["activated_calc"]
            calc_impl, _ = Implements.calc(fractal.__class__)
            return calc_impl(fractal, activated_calc, calc_kwargs)

        set_signature(impl, calc_sign)

        return impl


    def func_layers(self):
        """
        Setup the calculations ; Delegated to the fractal Plotting_protocol
        mixin.
        
        Needed closure:  fractal, plotter, postproc_batches
        Returned closure: None
        """
        layers_impl, layers_sign = Implements.layers(self.fractal_class)

        def impl(closure_vars, layers_kwargs):
            fractal = closure_vars["fractal"]
            activated_calc = closure_vars["selected_calc"]
#            postproc_batches = fractal.postproc_batches()
            layers_impl(fractal, activated_calc, layers_kwargs)

        set_signature(impl, layers_impl)

        return impl


    def func_rendering(self):
        """
        Apply the rendering option ("final render", supersampling, jitter,
        etc.)

        Needed closure:  postproc_batches
        Returned closure: fractal plotter

        Based on the Fractal_plotter __init__ method, from which we
            - fine-tune the "postproc_batches" parameter
            - remove the "self" parameter
        """
        def impl(closure_vars, rendering_kwargs):
            postproc_batches = closure_vars["postproc_batches"]
            return {
                "plotter": fractalshades.core.Fractal_plotter(
                        postproc_batches,
                        _delay_registering=True,
                        **rendering_kwargs
                )
            }

        parameters = []
        s = inspect.signature(fs.Fractal_plotter.__init__)
        for p_name, param in s.parameters.items():
            if p_name in ["self", "postproc_batch", "_delay_register"]:
                continue
            parameters += [param]
        gui_sign = Signature(parameters=parameters,
                         return_annotation=Signature.empty)

        set_signature(impl, gui_sign)
        return impl


    def func_plot(self):
        """
        Needed closure: fractal
        Returned closure:  postproc_batches
        """
        pass

#    def wrapup_signature(self):
#        """ 
#        Returns the full plotting function signature.
#        This is needed whenever a change of args impacts the signature itself
#        (hence the GUI compoenents)
#        """
        

    def wrapup(self):
        """ 
        Returns the full plotting function
        """
        def impl(funcs_kwargs_dict):
            """
            funcs_kwargs_dict: mapping of func_key -> kwargs
                {}
            """
            closure = self.closure(funcs_kwargs_dict)

            for func_key, func_kwargs in funcs_kwargs_dict.items():
                # Calling the successive functions with the right
                # kwargs and closure
                ret = self.func(func_key)(
                    closure, func_kwargs[func_key]
                )
                closure.update(ret)
        return impl


    def wrapup_code(self, funcs_kwargs_dict):
        """
        Returns the source code for the full plotting function
        """
        indent = 1
        shift_inc = " " * (4 * indent)

        source_code = ""
        closure = self.closure(funcs_kwargs_dict)
        
#        {
#            "fractal_class": self.fractal_class,
#            "directory": self.directory
#        }
        source_code += Code_writer.write_assignment(
            "closure",
            closure,
            indent
        )

        for func_key, func_kwargs in funcs_kwargs_dict.items():
            source_code += Code_writer.write_assignment(
                f"{func_key}_kwargs",
                func_kwargs,
                indent
            )

        for func_key in funcs_kwargs_dict.keys():
            source_code += "\n" + Code_writer.write_func(
                f"func_{func_key}",
                self.func(func_key)(),
                indent
            )
            source_code += "\n" + Code_writer.call_func_direct(
                f"func_{func_key}",
                f"closure, {func_key}_kwargs",
                indent
            )
            source_code += f"\n{shift_inc}closure.update(ret)"

        return source_code

    def wrapup_guiparams_default(self):
        """
        Utility function - return the default values for the parameters needed
        as input for wrapup method call
        """
        gui_params_default = dict()

        for func_key in self.func_keys():
            func = self.func(func_key)()
            sign = inspect.signature(func)
            gui_params_default[func_key] = {
                name: param.default 
                for name, param in sign.parameters.items()
            }

        return gui_params_default


class Implements():
    
    def __init__(self, **kwargs):
        """Decorator for a Fractal class or method used to specify a few
        options
        
        Typical usage:
            
            for a Fractal class:
                @implements(base="base_calc", interior="newton_calc")
            
            for a Fractal plotting method:
                @implements(
                    mandatory=("Continuous_iter",),
                    float_pp={
                        "Continuous_iter": {},
                        "DEM": {"px_snap": None},
                        "Fieldlines": {
                            "n_iter": None,
                            "swirl": None,
                            "damping_ratio": None
                        },  
                    },
                    normal_pp={
                        "DEM_normal": {
                            "kind": inspect.Parameter(
                                "kind", inspect.Parameter.KEYWORD_ONLY,
                                default="potential",
                                annotation=["potential", "Milnor"]
                            )
                        }
                    },
                    subset_params=None,
                )
        """
        self._plot_protocol = kwargs


    def __call__(self, fractal_obj):
        """
        Class wrapper - simply attach the _plotting_protocols dictionnary
        """
        fractal_obj._plot_protocol = self._plot_protocol
        return fractal_obj



    @staticmethod
    def calc(fractal_class, sgn_only=False):
        """
        Returns a generic postproc_batches list for this fractal

        Idea: build the signature first to allow "mapping" the parameters to
        the correct calculation
        """
        # calc_name -> str_method_name mapping
        calc_funcs = fractal_class._plot_protocol

        full_parameters = [] # full listing provided to GUI, with the titles
        mapped_parameters = {} # dict by calculations
        impl_subset = {} # dict of subset implementations

        for key_name, str_method in calc_funcs.items():
            calc_method = getattr(fractal_class, str_method)
            subset_params = calc_method._plot_protocol["subset_params"]

            # Adds a spacer
            full_parameters += [inspect.Parameter(
                "_" + key_name,
                kind=Parameter.KEYWORD_ONLY,
                annotation=separator,
                default=f"Parameters choice for {key_name}"
            )]

            # Adding the parameters to define the calculation
            s = inspect.signature(getattr(fractal_class, str_method))
            local_params = dict()
            for p_name, param in s.parameters.items():
                if p_name in ["self", "calc_name"]:
                    continue
                if p_name == "subset":
                    if subset_params is None:
                        impl_subset[key_name] = (lambda fractal : None)
                    else:
                        # It is a Fractal_array... Let's built a signature
                        # with the provided default
                        real_subset_params = subset_params.copy()
                        real_subset_params["calc_name"] = calc_funcs[
                            real_subset_params.pop("calc_name_key")
                        ]

                        def local_impl_subset(fractal):
                            return Fractal_array(
                                fractal=fractal, **real_subset_params
                            )
                        impl_subset[key_name] = local_impl_subset
                    continue

                local_params[param.name] = param.default
                full_parameters += [param]

            mapped_parameters[key_name] = local_params
        
        sgn = Signature(
            parameters=full_parameters, return_annotation=Signature.empty
        )

        if sgn_only:
            return sgn

        def impl(fractal, activated_calc, gui_kwargs):
            """
            Output: list of postproc_batches that can be passed to a plotter
            """
            postproc_batches = []

            for key_name, str_method in calc_funcs.items():
                calc_method = getattr(fractal_class, str_method)

                if key_name not in activated_calc: # This calculation is bypassed
                    logger.debug(
                        f"Skipping calc {str_method}:"
                        + f" not in {activated_calc}"
                    )
                    continue

                param_sset = mapped_parameters[key_name]
                params = {k: gui_kwargs[k] for k in param_sset}
                calc_subset = impl_subset[key_name](fractal)
                calc_method(fractal, subset=calc_subset, **params)

                postproc_batches += [Postproc_batch(fractal, key_name)]


            return {"postproc_batches": postproc_batches}

        return impl, sgn


    @staticmethod
    def layers(fractal_class, postproc_batches, plotter, sgn_only=False):
        """
        Returns a generic postproc_batches list for this fractal

        postproc batch1
          - base field
          - secondary field
          - shading
          - undef_color

        Idea: build the signature first to allow "mapping" the parameters to
        the correct calculation

        Parameters naming convention :

            b{i}_f{j}_param   (float postproc)
            b{i}_n{j}_param    (normal postproc)
            b{i}_mask_param    (mask postproc)
        """
        # calc_name -> str_method_name mapping
        calc_funcs = fractal_class._plot_protocol

        full_parameters = [] # full listing provided to GUI, with the titles
        mapped_parameters = {} # dict by calculations / postproc == pp btaches
        impl_mask = {} # dict of mask implementations

        for ib, batch in enumerate(postproc_batches): #calculations.items(): # Should we loop on pp
            mapped_parameters[ib] = {"f": {}, "n": {}} # float / normal
            calc_name = batch.calc_name
            calc_method = getattr(fractal_class, calc_funcs[calc_name])
            # mandatory_pps = calc_method._plot_protocol["mandatory"]
            float_pps = calc_method._plot_protocol["float_pp"]
            normal_pps = calc_method._plot_protocol["normal_pp"]

            
#            calc_method = getattr(fractal_class, str_method)
#            subset_params = calc_method._plot_protocol["subset_params"]

            # Adds a spacer
            full_parameters += [inspect.Parameter(
                f"_{ib}_{key_name}",
                kind=Parameter.KEYWORD_ONLY,
                annotation=separator,
                default=f"** Layer choice for {key_name}"
            )]

            # Adding the parameters to define the layers
            # Adding the pp that are compulsary
            
            for ipp, pp in enumerate(float_pps):
                prefix = f"b{ib}f{ipp}"
                mapped_parameters[ib]["f"][ipp] = []
                
                sep_pp = inspect.Parameter(
                    f"_prefix_{pp}", kind=Parameter.KEYWORD_ONLY,
                    annotation=separator, default=f"Layer {prefix}: {pp}"
                )
                full_parameters += [sep_pp]

                # Do we add greyscale export ?
                greyscale_export_param = Parameter(
                    f"{prefix}_greyscale_export",
                    kind=Parameter.KEYWORD_ONLY,
                    annotation=bool,
                    default=True
                )
                # Then -> func=None, curve=lambda x: 0.5 + (x - 0.5) * 0.2, output
                
                full_parameters += [greyscale_export_param]
                mapped_parameters[ib]["f"][ipp] += [greyscale_export_param]
                
                # add pp signature params
                s = inspect.signature(getattr(pp + "_pp", "__init__"))
                for p_name, param in s.parameters.items():
                    if p_name in ["self"]:
                        continue
                    local_param = Parameter(
                        f"{prefix}_{p_name}",
                        kind=Parameter.KEYWORD_ONLY,
                        annotation=param.annotation,
                        default=param.default
                    )
                    parameters[ib]["f"][ipp] += [local_param]
            
            # Same loop for 
            
            # Color for masked 

                
                
                full_parameters += []
                
                assert mandat_classname in float_pp.keys()
                mandat_params = float_pp[mandat_classname]
                pp_class = getattr(
                    fractalshades.postproc, mandat_classname + "_pp"
                )
                s = inspect.signature(getattr(fractal_class, str_method))

            for layers in float_pp:
                
            s = inspect.signature(getattr(fractal_class, str_method))

            local_params = dict()
            for p_name, param in s.parameters.items():
                if p_name in ["self", "calc_name"]:
                    continue

                local_params[param.name] = param.default
                full_parameters += [param]

            mapped_parameters[key_name] = local_params

        sgn = Signature(
            parameters=full_parameters, return_annotation=Signature.empty
        )

        if sgn_only:
            return sgn

        # =====================================================================
        def impl(fractal, plotter, postproc_batches, gui_kwargs):
            """
            Output: None, this is the main plotting code
            
            
            """
            plotter = fs.Fractal_plotter(
                    [pp, pp_int], final_render=test_final,
                    _delay_register=True
            )

            for ib, batch in postproc_batches:
                prefix = f"b{ib}f{ipp}"
                
                calc_name = batch.calc_name
                calc_method = getattr(fractal_class, calc_funcs[calc_name])
                mandatory = calc_method._plot_protocol["mandatory"]
                float_pp = calc_method._plot_protocol["float_pp"]
                normal_pp = calc_method._plot_protocol["normal_pp"]
                mask_pp = calc_method._plot_protocol["normal_pp"]
                

                # 1) The post processed fields
                
                # Adding the pp that are compulsary
                for ipp, pp in enumerate(float_pp):
                    
                    # Some logic to double check if we activate...
                    
                    batch.add_postproc(
                        "cont_iter",
                        getattr(fractal_class, "__init__")(
                            **pp_kwargs[ib, ipp]
                        )
                    )
                
                for mandat_classname in mandatory_pp:
                    assert mandat_classname in float_pp.keys()
                    mandat_params = float_pp[mandat_classname]

                    mandat_kw = {p: gui_kwargs[p] for p in mandat_params}
                    # E.g;, : Continuous_iter_pp...
                    pp_class = getattr(
                        fractalshades.postproc, mandat_classname + "_pp"
                    )
                    pp.add_postproc(mandat_classname, pp_class(mandat_kw))

                # Adding the bool pp + layer
                for key, val in mask_pp:
                    
                pp.add_postproc(
                    f"mask_{calc_name}",
                    Raw_pp(**mask_pp)
                )
                plotter.add_layer(Bool_layer(
                        f"mask_{calc_name}", output=False)
                )

                # Adding the base pp 
                
                # Adding the secondary pp
                # ? grey or Color ??
                
                # Adding the normal map pp
                
                
                # 2) The layers
                plotter.add_layer(
                
                

                if key_name not in activated_calc: # This calculation is bypassed
                    logger.debug(
                        f"Skipping all layers related to {str_method}:"
                        + f" not in {activated_calc}"
                    )
                    continue

                # param_sset = mapped_parameters[key_name]
                params = {k: gui_kwargs[k] for k in param_sset}
                calc_subset = impl_subset[key_name](fractal)
                calc_method(fractal, subset=calc_subset, **params)

                postproc_batches += [Postproc_batch(fractal, key_name)]
                

            return {}

        return impl, sgn
            

#    def layers(fractal_class):
#        """
#        This fine-tune the plotter
#        """
#        calculations = fractal_class._plot_protocol
#                
#
#        def impl(fractal, plotter, gui_kwargs):
#
#            for key_name, str_method in calculations.items():
#
#                plotter.add_layer(Bool_layer("interior", output=False)
#                
#                # the base calc
#                
#                # the 
#            
#            
#    
#    return impl, sgn

        
        

#def implements_plotting(**kwargs):
#    """
#    Class factory for Plotting_protocol derived classes.
#
#    Parameters:
#    -----------
#    Continuous_iter: bool
#        If True, can define a Continuous_iter_pp()
#    Fieldlines_pp: bool
#        If True, can define a Fieldlines_pp() 
#    DEM_pp: bool
#        If True, can define a DEM_normal_pp() 
#    DEM_normal_pp: None | str[]
#        If not None, can define a DEM_pp with kind from the str[] list which
#        take value in "potential" | "Milnor" | "convergent"
#        DEM_normal_pp(kind=str)
#    DEM_pp: bool
#        If True, can define a DEM_pp
#    
#    """
#    class Implements_plotting(Plotting_protocol):
#        implements = kwargs
#
#    return Implements_plotting






def test_Code_writer():
    val = np.pi
    val = {"abs": np.pi, "c": 4.59785}
    a = val
    for a in (
        np.pi,
        {"abs": np.pi, "c": 4.59785},
        {1: np.pi, 2: "xxx", 3: {"abs": np.pi, "c": 4.59785}},
    ):
        res = Code_writer.write_assignment("test", a, 1)
        print(f"res({a}):\n{res}")
    
    def f(x):
        return x
    
    res = Code_writer.write_func("ff", f, indent=1)
    print(f"func f:\n{res}")
    
    res = Code_writer.call_func("f", {"abs": np.pi, "c": 4.59785}, indent=1)
    print(f"func f:\n{res}")
    

if __name__ == "__main__":
    
    import fractalshades.models as fsm
    
    realpath = os.path.realpath(__file__)
    directory = os.path.splitext(realpath)[0]
    fractal_c = fsm.Mandelbrot #Perturbation_mandelbrot# (directory)

    pf = Plotting_Factory(fractal_c, directory)
    
    guiparams_default = pf.wrapup_guiparams_default()
    print("**********************************************************")
    print("guiparams_default\n", guiparams_default)
    print("**********************************************************")
    
    # guiparams_default["general_settings"]["verbosity"] = -314

    gui_source_code = pf.wrapup_code(guiparams_default)
    
    print("************* gui_source_code:\n*")
    print(gui_source_code)
    
#    print(f_impl)
#    
#    print("*** signature:\n", inspect.signature(f_impl))
#    print("*** signature:\n", f_impl.__signature__)
#    print("*** source:\n", inspect.getsource(f_impl))
#    print("*** doc:\n", f_impl.__doc__)
    
#    f = f_impl(directory=directory)
#    print("")
#    
#    print(get_signature_details(f_impl.__signature__))
#    print(f_impl.__closure__[0].cell_contents)
    # test_Code_writer()
    
    # print(func.__annotations__)
    # func(x="0.", y="0.", dx="5.0")
    
#    sign = inspect.signature(func, follow_wrapped=False)
#    for i_param, (name, param) in enumerate(sign.parameters.items()):
#        print(i_param, name, param)



#
#
#def generic_plot(plot_dir, fractal, **user_kwargs):
#    """
#    This will launch a GUI explorer with functionalities offered by the 
#    fractal class
#    """
#    field_dic = fractal.field_dic
#    
#    # Typing
#    shade_kind_type = typing.Literal["None", "standard", "glossy"]
#    
#    
#    x = '-1.0'
#    y = '-0.0'
#    dx = '5.0'
#    calc_name = 'test'
#
#    xy_ratio = 1.0
#    dps = 16
#    max_iter = 15000
#    M_divergence = 1.e2
#    nx = 800
#    theta_deg = 0.
#    interior_detect = True
#    epsilon_stationnary = 0.001
#    eps = 1.e-6
#    
#    base_layer = "continuous_iter"
#    colormap = fscolors.cmap_register["classic"]
#    cmap_z_kind = "relative"
#    zmin = 0.00
#    zmax = 0.50
#    
#    shade_kind="glossy"
#    field_kind="None"
#
#    # Set to True to enable multi-threading
#    settings.enable_multithreading = False
#
#    directory = plot_dir
#    fractal = fsm.Perturbation_mandelbrot(directory)
#    
#    def func(
#        fractal: fsm.Perturbation_mandelbrot=fractal,
#         calc_name: str=calc_name,
#
#         _1: fsgui.separator="Zoom parameters",
#         x: mpmath.mpf=x,
#         y: mpmath.mpf=y,
#         dx: mpmath.mpf=dx,
#         xy_ratio: float=xy_ratio,
#         theta_deg: float=theta_deg,
#         dps: int=dps,
#         nx: int=nx,
#         antialiasing: bool=False,
#
#         _2: fsgui.separator="Calculation parameters",
#         max_iter: int=max_iter,
#         M_divergence: float=M_divergence,
#         interior_detect: bool=interior_detect,
#         epsilon_stationnary: float=epsilon_stationnary,
#
#         _3: fsgui.separator="Bilinear series parameters",
#         use_BLA: bool=True,
#         eps: float=eps,
#
#         _4: fsgui.separator="Plotting parameters: base field",
#         base_layer: typing.Literal[
#                 "continuous_iter",
#                 "distance_estimation"
#         ]=base_layer,
#         interior_mask: typing.Literal[
#                 "all",
#                 "not_diverging",
#                 "dzndz_detection",
#         ]="all",
#         interior_color: QtGui.QColor=(0.1, 0.1, 0.1),
#         colormap: fscolors.Fractal_colormap=colormap,
#         invert_cmap: bool=False,
#         # cmap_z_kind: typing.Literal["relative", "absolute"]=cmap_z_kind,
#         zmin: float=zmin,
#         zmax: float=zmax,
#
#         _5: fsgui.separator="Plotting parameters: shading",
#         shade_kind: typing.Literal["None", "standard", "glossy"]=shade_kind,
#         gloss_intensity: float=10.,
#         light_angle_deg: float=65.,
#         light_color: QtGui.QColor=(1.0, 1.0, 1.0),
#         gloss_light_color: QtGui.QColor=(1.0, 1.0, 1.0),
#
#         _6: fsgui.separator="Plotting parameters: field lines",
#         field_kind: typing.Literal["None", "overlay", "twin"]=field_kind,
#         n_iter: int=3,
#         swirl: float=0.,
#         damping_ratio: float=0.8,
#         twin_intensity: float=0.1
#    ):
#
#        fractal.zoom(
#            precision=dps,
#            x=x,
#            y=y,
#            dx=dx,
#            nx=nx,
#            xy_ratio=xy_ratio,
#            theta_deg=theta_deg,
#            projection="cartesian",
#            antialiasing=antialiasing
#        )
#        
#        print("DEBUGGING zoom", fractal.zoom_kwargs)
#
#        if use_BLA:
#            BLA_params={"eps": eps}
#        else:
#            BLA_params = None
#            
#        fractal.calc_std_div(
#                calc_name=calc_name,
#                subset=None,
#                max_iter=max_iter,
#                M_divergence=M_divergence,
#                epsilon_stationnary=epsilon_stationnary,
#                SA_params=None,
#                BLA_params=BLA_params,
#                interior_detect=interior_detect,
#            )
#
#        if fractal.res_available(calc_name):
#            print("RES AVAILABLE, no compute")
#        else:
#            print("RES NOT AVAILABLE, clean-up")
#            fractal.clean_up(calc_name)
#
##        fractal.run()
#
#        pp = Postproc_batch(fractal, calc_name)
#        
#        if base_layer == "continuous_iter":
#            pp.add_postproc(base_layer, Continuous_iter_pp())
#        elif base_layer == "distance_estimation":
#            pp.add_postproc("continuous_iter", Continuous_iter_pp())
#            pp.add_postproc(base_layer, DEM_pp())
#
#        if field_kind != "None":
#            pp.add_postproc(
#                "fieldlines",
#                Fieldlines_pp(n_iter, swirl, damping_ratio)
#            )
#
#        interior_func = {
#            "all": lambda x: x != 1,
#            "not_diverging": lambda x: x == 0,
#            "dzndz_detection": lambda x: x == 2,
#        }[interior_mask]
#        pp.add_postproc("interior", Raw_pp("stop_reason", func=interior_func))
#
#        if shade_kind != "None":
#            pp.add_postproc("DEM_map", DEM_normal_pp(kind="potential"))
#
#        plotter = fs.Fractal_plotter(pp)
#
#        plotter.add_layer(Bool_layer("interior", output=False))
#
#        if field_kind == "twin":
#            plotter.add_layer(Virtual_layer(
#                    "fieldlines", func=None, output=False
#            ))
#        elif field_kind == "overlay":
#            plotter.add_layer(Grey_layer(
#                    "fieldlines", func=None, output=False
#            ))
#
#        if shade_kind != "None":
#            plotter.add_layer(Normal_map_layer(
#                "DEM_map", max_slope=60, output=True
#            ))
#
#        if base_layer != 'continuous_iter':
#            plotter.add_layer(
#                Virtual_layer("continuous_iter", func=None, output=False)
#            )
#
#        sign = {False: 1., True: -1.}[invert_cmap]
#        plotter.add_layer(Color_layer(
#                base_layer,
#                func=lambda x: sign * np.log(x),
#                colormap=colormap,
#                probes_z=[zmin, zmax],
#                probes_kind=cmap_z_kind,
#                output=True))
#        plotter[base_layer].set_mask(
#            plotter["interior"], mask_color=interior_color
#        )
#
#        if field_kind == "twin":
#            plotter[base_layer].set_twin_field(plotter["fieldlines"],
#                   twin_intensity)
#        elif field_kind == "overlay":
#            overlay_mode = Overlay_mode("tint_or_shade", pegtop=1.0)
#            plotter[base_layer].overlay(plotter["fieldlines"], overlay_mode)
#
#        if shade_kind != "None":
#            light = Blinn_lighting(0.4, np.array([1., 1., 1.]))
#            light.add_light_source(
#                k_diffuse=0.8,
#                k_specular=.0,
#                shininess=350.,
#                angles=(light_angle_deg, 20.),
#                coords=None,
#                color=np.array(light_color))
#
#            if shade_kind == "glossy":
#                light.add_light_source(
#                    k_diffuse=0.2,
#                    k_specular=gloss_intensity,
#                    shininess=1400.,
#                    angles=(light_angle_deg, 20.),
#                    coords=None,
#                    color=np.array(gloss_light_color))
#    
#            plotter[base_layer].shade(plotter["DEM_map"], light)
#
#        plotter.plot()
#        
#        # Renaming output to match expected from the Fractal GUI
#        layer = plotter[base_layer]
#        file_name = "{}_{}".format(type(layer).__name__, layer.postname)
#        src_path = os.path.join(fractal.directory, file_name + ".png")
#        dest_path = os.path.join(fractal.directory, calc_name + ".png")
#        if os.path.isfile(dest_path):
#            os.unlink(dest_path)
#        os.link(src_path, dest_path)
#
#
#    gui = fsgui.Fractal_GUI(func)
#    gui.connect_image(image_param="calc_name")
#    gui.connect_mouse(x="x", y="y", dx="dx", xy_ratio="xy_ratio", dps="dps")
#    gui.show()

