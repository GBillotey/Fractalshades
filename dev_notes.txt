
Programme structure
https://blog.ionelmc.ro/2014/05/25/python-packaging/

Packaging
https://packaging.python.org/tutorials/packaging-projects/

Requirement
wx.python
pip install wxPython==4.1.1

Introspecting callables with the Signature object
https://docs.python.org/3.5/library/inspect.html#inspect.signature
https://docs.python.org/3.10/library/typing.html#typing.ParamSpec
https://docs.python.org/3.10/library/typing.html#typing.Callable
https://www.python.org/dev/peps/pep-0589/
_______________________________________________
Template

import fractalshades as fs
import fractalshades.models as fsm

mandelbrot = fsm.Perturbation_mandelbrot( *****)
calc = mandelbrot.set_calc()
  -> factory method + inspection

plotter = fs.Fractal_plotter(calc, ****)

plotter.explore()

________________________________________
Compile
https://nuitka.net/pages/download.html
https://sametmax.com/vive-setup-cfg-et-mort-a-pyproject-toml/

________________________________________
PyQt5
https://www.riverbankcomputing.com/static/Docs/PyQt5/index.html
https://www.mfitzp.com/tutorials/plotting-matplotlib/

Great tutorial :
https://www.tutorialspoint.com/pyqt5/index.htm

https://codeloop.org/how-to-load-qt-designer-ui-file-in-pyqt5/
Converting UI files to Python
Both libraries provide identical scripts to generate Python importable modules from Qt Designer .ui files. For PyQt5 the script is named pyuic5 â€”
https://www.mfitzp.com/news/pyqt5-vs-pyside2/
pyuic5 mainwindow.ui -o MainWindow.py

https://doc.qt.io/qt-5/qtwidgets-widgets-scribble-example.html
with BSD3 License ? yes
https://doc.qt.io/archives/3.3/faq.html#5-3
https://opensource.org/licenses

https://doc.qt.io/qt-5/qtwidgets-index.html
__________________________________
Refactoring call signature of loop
def loop_xxxx(**
              calc_params{loop_params:{M_divergence: xxx
                                       epsilon_stationnary: 
                                       pc_threshold: 


f = Myfractal()
f.zoom(**zoom_params)
f.process(**process_params)  (including calc_kind ?)
calc_params = FP_params
              SA_params

Then subsequent run runs everything
f.run()

zoom_params by inspection of zoom call parameters
calc_params by inspection of calc call parameters
FP_params by inspection of full_loop call parameters
SA_params by inspection of full_loop call parameters
dataype by inspection of ...
etc...

THE MODEL-VIEW
https://doc.qt.io/archives/qq/qq21-datawidgetmapper.html

___________________________________________________________
new in 3.8 ...

class point2D(typing.TypedDict, total=False):
    x: int
    y: int
    

point2D
Out[11]: __main__.point2D

point2D.__dict__
Out[12]: 
mappingproxy({'__module__': '__main__',
              '__annotations__': {'x': int, 'y': int},
              '__new__': <staticmethod at 0x7f584c200e80>,
              '__dict__': <attribute '__dict__' of 'point2D' objects>,
              '__weakref__': <attribute '__weakref__' of 'point2D' objects>,
              '__doc__': None,
              '__total__': False})

point2D.__annotations__
Out[13]: {'x': int, 'y': int}

Better : (Python > 3.8)
from typing import Union, get_origin, get_args

https://stackoverflow.com/questions/31221391/how-to-use-qdatawidgetmapper-in-qt-or-pyqt
https://doc.qt.io/qt-5/qdatawidgetmapper.html


SAFE EVAL ??
ast.literal_eval()
https://newville.github.io/asteval/motivation.html#how-safe-is-asteval     

# Gui_launcher
class GUI_Fractal(plot_func, plot_im, zoom_mapping(zoom_x="", zoom_y="", zoom_xy_ratio=""))
GUI_Fractal.explore()


# QIMAGE
https://stackoverflow.com/questions/3041728/bug-when-drawing-a-qimage-on-a-widget-with-pil-and-pyqt

# Model - view
app-level class fQModel : nested dicts
          
to each Widget(self, parent, key)
    responsible to send model_item_modified_event(key, val)

 valueChanged = pyqtSignal(object)  
Notice the signal has one argument of type object, which should allow anything to pass through. Then, you should be able to emit the signal from within the class using an argument of any data type:

_____________________________________________________________

https://mpmath.org/doc/current/setup.html#using-gmpy-optional
>>> import mpmath.libmp
>>> mpmath.libmp.BACKEND 
should be .... currently 'python'
'gmpy'
OK !

API :

gui = Fractal_GUI(func, view=image_prefix)
gui.connect_mouse(out=("x", "y", "dx"), in=("xy_ratio",))
gui.show()



model = Model()
func = Func_submodel(model, tuple(["func"]), func)
image = Image_presenter(model, mapping)


________________________________________________
pretty print
https://docs.python.org/2/library/tokenize.html


__________________________________________________________________________
HOW TO JIT / NUMBA
c.context.enable_nrt:
The NRT is used to manage reference-counted memory allocation and is not available on the GPU.

Plans :
1) custom lowering + boxing / unboxing on Xrange_array + support a subset of operations through
operator overload : +, *
overload operator
https://github.com/numba/numba/pull/2983
nd array lowering / boxing
https://gist.github.com/sklam/04e722fdf5cb215ff909ae4908712da7
need to use :
def array_complex_attr(context, builder, typ, value, attr):

2) custom lowering + boxing / unboxing on Xrange_polynomial. probably group with Xrange_serie


3) datatype dedicated to fractal main looping (C struct ?)
return the function in a closure
see https://numba.pydata.org/numba-doc/dev/user/faq.html
(not : no parallell in sus of multiprocessing)
https://numba.pydata.org/numba-doc/latest/user/cfunc.html#handling-c-structures

my_struct = types.Record.make_c_struct([
   # Provides a sequence of 2-tuples i.e. (name:str, type:Type)
   ('i1', types.int32),
   ('f2', types.float32),
   ('d3', types.float64),
   ('af4', types.NestedArray(dtype=types.float32, shape=(7,))),
])








 
